//! The Loop project
//!
//! A high level over view of how Loop executes code is simple:
//! - Use the [lexer] to lex the input string, which outputs tokens
//! - Use the [parser] to parse the input tokens, which outputs a syntax tree
//! - Use the [compiler] to compile the input syntax tree, which outputs D code
//! - Use the embedded D compiler to compile to an executable
//! - Call the executable that was generated
//!
//! A more detailed walk through the code looks like this
//! - Call [execute_code] with a string
//! ```
//! let executed = execute_code("var x = 100".to_string());
//! ```
//! - Then [execute_code] will go through this process
//!     - Create a lexer instance using [lexer::build_lexer] with the input string
//!     - Create a parser instance [parser::build_parser] with the tokens generated by build_lexer
//!     - Call [parser::Parser::parse] which will actually parse the tokens into an [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree)
//!     - Create a compiler instance using [compiler::build_compiler]
//!     - Call [compiler::Compiler::compile] to compile the AST into [compiler::Bytecode]
//!     - Go through all imports & function declarations that are stored in the bytecode
//!       And create a D compatible string
//!     - Write the D string to a file
//!     - Compile the D file using the embedded D compiler
//!     - Execute the binary generated by the D compiler
extern crate strum;
#[macro_use]
extern crate strum_macros;
use crate::lib::config::{load_config, LoadType};
use crate::lib::util::execute_code;
use dirs::home_dir;
use lib::flags;
use lib::repl::build_repl;
use std::env;
use std::fs::read_to_string;

pub mod compiler;
pub mod lexer;
mod lib;
pub mod parser;

/// Entry point of Loop, runs pre-flight checks to ensure everything necessary exists
fn main() {
    let args: Vec<String> = env::args().collect();

    if args.len() == 2 && args[1] == "version" {
        println!("{}", env!("CARGO_PKG_VERSION"));

        return;
    }

    let flags = get_flags();

    match load_config() {
        LoadType::FirstRun(cfg) => {
            if flags.file.is_none() {
                println!("This is your first time running Loop! (Or your config was re-generated)");
                println!("Configuration file is at: ");
                println!(
                    "{}\\.loop\\config.toml",
                    home_dir().unwrap().to_str().unwrap()
                );
            }

            cfg
        }

        LoadType::Normal(cfg) => cfg,
    };

    if let Some(file) = flags.file {
        run_file(file);
    } else {
        build_repl().start();
    }
}

/// Runs a Loop file
fn run_file(path: String) {
    let content = read_to_string(path);

    let result = execute_code(content.ok().unwrap().as_str());

    if result.is_err() {
        println!("{}", result.unwrap_err());
    }
}

/// Parses all CLI arguments passed to the Loop executable
fn get_flags() -> flags::Flags {
    let mut args: Vec<String> = env::args().collect();
    args = args[1..].to_owned();

    let mut flags = flags::build_flags();
    flags.parse_flags(args);
    flags
}
